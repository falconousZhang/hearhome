package com.example.hearhome.ui.auth

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.hearhome.data.local.User
import com.example.hearhome.data.local.UserDao
import com.example.hearhome.data.remote.ApiService
import com.example.hearhome.data.remote.LoginRequest
import io.ktor.client.call.*
import io.ktor.http.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class AuthViewModel(
    private val userDao: UserDao
) : ViewModel() {

    sealed class AuthState {
        object Idle : AuthState()
        object AwaitingInput : AuthState()
        object Loading : AuthState()
        data class Success(val user: User) : AuthState()
        data class RegisterSuccess(val user: User) : AuthState()
        object PasswordResetReady : AuthState()
        object PasswordResetSuccess : AuthState()
        object UpdateSuccess : AuthState()
        object PasswordUpdateSuccess : AuthState()
        data class Error(val message: String) : AuthState()
    }

    private val _authState = MutableStateFlow<AuthState>(AuthState.Idle)
    val authState: StateFlow<AuthState> = _authState

    private var currentEmailForReset: String? = null
    private var currentSecQuestion: String? = null
    private var resetAnswerPlain: String? = null

    /** ===== 给 MainActivity / LoginScreen 清一次性状态 ===== */
    fun resetAuthResult() { _authState.value = AuthState.Idle }

    /** =====（如果 UI 用到）ProfileScreen 消费完事件后回到可交互状态 ===== */
    fun onProfileEventConsumed() { _authState.value = AuthState.AwaitingInput }

    /** ===== 登录（走后端） ===== */
    fun login(email: String, password: String) {
        viewModelScope.launch {
            if (email.isBlank() || password.isBlank()) {
                _authState.value = AuthState.Error("邮箱和密码不能为空")
                return@launch
            }
            _authState.value = AuthState.Loading
            try {
                val resp = ApiService.login(LoginRequest(email.trim(), password))
                when (resp.status) {
                    HttpStatusCode.OK -> _authState.value = AuthState.Success(resp.body<User>())
                    HttpStatusCode.BadRequest, HttpStatusCode.NotFound, HttpStatusCode.Unauthorized -> {
                        val gr = resp.body<com.example.hearhome.data.remote.GenericResponse>()
                        _authState.value = AuthState.Error(gr.message)
                    }
                    else -> _authState.value = AuthState.Error("登录失败：${resp.status.value}")
                }
            } catch (e: Exception) {
                _authState.value = AuthState.Error("登录失败: ${e.message}")
            }
        }
    }

    /** ===== 注册（走后端） ===== */
    fun register(
        email: String,
        password: String,
        secQuestion: String,
        secAnswer: String,
        nickname: String,
        gender: String
    ) {
        viewModelScope.launch {
             // 1. 输入验证
            if (nickname.isBlank() || email.isBlank() || password.isBlank()) {
                _authState.value = AuthState.Error("昵称、邮箱和密码为必填项")
                return@launch
            }
            if (password.length < 6) {
                 _authState.value = AuthState.Error("密码不能少于6位")
                return@launch
            }

            // 2. 设置加载状态
            _authState.value = AuthState.Loading

            try {
                val user = User(
                    // uid is not needed for registration, it will be generated by the backend
                    email = email.trim(),
                    password = password, // Password should be sent as is, hashing should be on server side
                    nickname = nickname.trim(),
                    secQuestion = secQuestion.trim(),
                    secAnswerHash = secAnswer.trim(), // MODIFIED: Corrected parameter name
                    gender = gender
                )

                // 3. 调用 API
                val response = ApiService.register(user)

                // 4. 处理响应
                if (response.status == HttpStatusCode.Created) {
                    val registeredUser = response.body<User>()
                    _authState.value = AuthState.RegisterSuccess(registeredUser)
                } else {
                    val errorBody = response.body<com.example.hearhome.data.remote.GenericResponse>()
                    _authState.value = AuthState.Error(errorBody.message)
                }
            } catch (e: Exception) {
                _authState.value = AuthState.Error("注册失败: ${e.message}")
            }
        }
    }

    /** ===== 个人中心 → 修改密码（/users/update-password） ===== */
    fun updatePassword(
        email: String,
        oldPassword: String,
        securityAnswer: String,
        newPassword: String,
        confirmPassword: String
    ) {
        viewModelScope.launch {
            if (oldPassword.isBlank() || securityAnswer.isBlank() || newPassword.isBlank() || confirmPassword.isBlank()) {
                _authState.value = AuthState.Error("所有字段均不能为空"); return@launch
            }
            if (newPassword.length < 6) { _authState.value = AuthState.Error("新密码至少 6 位"); return@launch }
            if (newPassword != confirmPassword) { _authState.value = AuthState.Error("两次输入的新密码不一致"); return@launch }

            _authState.value = AuthState.Loading
            try {
                val resp = ApiService.updatePassword(email.trim(), oldPassword, securityAnswer, newPassword)
                when (resp.status) {
                    HttpStatusCode.OK -> _authState.value = AuthState.PasswordUpdateSuccess
                    HttpStatusCode.BadRequest, HttpStatusCode.NotFound -> {
                        val gr = resp.body<com.example.hearhome.data.remote.GenericResponse>()
                        _authState.value = AuthState.Error(gr.message)
                    }
                    else -> _authState.value = AuthState.Error("修改失败：${resp.status.value}")
                }
            } catch (e: Exception) {
                _authState.value = AuthState.Error("修改失败：${e.message}")
            }
        }
    }

    /** ===== 个人中心 → 设置/修改密保（/users/update-security-question） ===== */
    fun updateSecurityQuestion(email: String, password: String, question: String, answer: String) {
        viewModelScope.launch {
            if (password.isBlank() || question.isBlank() || answer.isBlank()) {
                _authState.value = AuthState.Error("密码、问题和答案均不能为空"); return@launch
            }
            _authState.value = AuthState.Loading
            try {
                val resp = ApiService.updateSecurityQuestion(email.trim(), password, question.trim(), answer.trim())
                when (resp.status) {
                    HttpStatusCode.OK -> _authState.value = AuthState.UpdateSuccess
                    HttpStatusCode.BadRequest, HttpStatusCode.NotFound -> {
                        val gr = resp.body<com.example.hearhome.data.remote.GenericResponse>()
                        _authState.value = AuthState.Error(gr.message)
                    }
                    else -> _authState.value = AuthState.Error("更新失败：${resp.status.value}")
                }
            } catch (e: Exception) {
                _authState.value = AuthState.Error("更新失败：${e.message}")
            }
        }
    }

    /** ===== 忘记密码 Step 1：获取密保问题（/users/reset-question） ===== */
    fun startResetByQuestion(email: String) {
        viewModelScope.launch {
            if (email.isBlank()) { _authState.value = AuthState.Error("请填写邮箱"); return@launch }
            _authState.value = AuthState.Loading
            try {
                val resp = ApiService.fetchResetQuestion(email.trim())
                when (resp.status) {
                    HttpStatusCode.OK -> {
                        val q = resp.body<com.example.hearhome.data.remote.SecurityQuestionResponse>()
                        if (q.question.isBlank()) {
                            _authState.value = AuthState.Error("该账号未设置密保问题")
                        } else {
                            currentEmailForReset = email.trim()
                            currentSecQuestion = q.question
                            _authState.value = AuthState.PasswordResetReady
                        }
                    }
                    HttpStatusCode.NotFound, HttpStatusCode.BadRequest -> {
                        val gr = resp.body<com.example.hearhome.data.remote.GenericResponse>()
                        _authState.value = AuthState.Error(gr.message)
                    }
                    else -> _authState.value = AuthState.Error("获取密保问题失败：${resp.status.value}")
                }
            } catch (e: Exception) {
                _authState.value = AuthState.Error("获取密保问题失败：${e.message}")
            }
        }
    }

    /** 提供给 UI 展示当前密保问题 */
    fun getCurrentResetQuestion(): String? = currentSecQuestion

    /** ===== 忘记密码 Step 2：不本地校验，只暂存答案 ===== */
    fun verifyAnswer(answer: String): Boolean {
        resetAnswerPlain = answer
        return true
    }

    /** ===== 忘记密码 Step 3：提交到后端校验并重置（/users/reset-password） ===== */
    fun setNewPassword(newPassword: String) {
        viewModelScope.launch {
            val email = currentEmailForReset
            val answer = resetAnswerPlain
            if (email.isNullOrBlank() || answer.isNullOrBlank()) {
                _authState.value = AuthState.Error("流程异常，请重试"); return@launch
            }
            if (newPassword.length < 6) { _authState.value = AuthState.Error("新密码至少 6 位"); return@launch }

            _authState.value = AuthState.Loading
            try {
                val resp = ApiService.resetPasswordByAnswer(email, answer.trim(), newPassword)
                when (resp.status) {
                    HttpStatusCode.OK -> {
                        currentEmailForReset = null
                        currentSecQuestion = null
                        resetAnswerPlain = null
                        _authState.value = AuthState.PasswordResetSuccess
                    }
                    HttpStatusCode.BadRequest, HttpStatusCode.NotFound -> {
                        val gr = resp.body<com.example.hearhome.data.remote.GenericResponse>()
                        _authState.value = AuthState.Error(gr.message)
                    }
                    else -> _authState.value = AuthState.Error("重置失败：${resp.status.value}")
                }
            } catch (e: Exception) {
                _authState.value = AuthState.Error("重置失败：${e.message}")
            }
        }
    }
}
